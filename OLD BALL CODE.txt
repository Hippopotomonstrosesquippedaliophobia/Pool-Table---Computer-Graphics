// ==============================================================================
//  PROGRAM:
//  Pool Table
// ==============================================================================

// ==============================================================================
//  Steps to create the MVP:
//    1.  Setup and compile our shaders as an object of the Shader class.
//    2.  Load the geometrical model objects.
//    3.  Create the projection matrix.
//    4.  Create the view matrix
//    5.  Create the model matrix – initially as an identity matrix and
//        then modify with scaling, translation, rotation, etc, if required.
//    6.  Pass the model, view and projection matrices to the shaders.
//    7.  Draw the object.
//
// ==============================================================================
/*============================================================================= =
Install the following in Package Manager :

Install-Package glew_dynamic
Install-Package glfw
Install-Package GLMathematics
Install-Package freeimage -version 3.16.0
Install-Package nupengl.core
Install-Package Soil
Install-Package Assimp -version 3.0.0

=================================================================================*/
// GLEW
#include <GL/glew.h>

// GLFW
#include <GLFW/glfw3.h>

// GLM Mathemtics
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

// GL includes
#include "shader.h"
#include "camera.h"
#include "model.h"

//========= Prototype function for call back ===============================
//Keyboard callback for Functions like closing etc
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode);

void windowSize_callback(GLFWwindow* window, int width, int height);

void clicked_callback(GLFWwindow* window, int button, int  action, int mode);

void clickDrag_callback(GLFWwindow* window, double xPos, double yPos);

void moveMouse_callback(GLFWwindow* window, double xPos, double yPos);

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
//==========================================================================

#define ballCount 2

// Active window
GLFWwindow* window;

// Properties
GLuint sWidth = 1000, sHeight = 800;

//Initial Camera location
glm::vec3 originalLocation = glm::vec3(0.0f, 500.0f, 2000.0f);
glm::vec3 camLocation = originalLocation;

//Camera
Camera camera(camLocation);
glm::mat4 View;

// Deltatime - for camera movement
GLfloat deltaTime = 0.0f;    // Time between current frame and last frame
GLfloat lastFrame = 0.0f;    // Time of last frame
GLfloat currentFrame;

//Variables increments for resetting the camera's coordinates
GLfloat xVal = 700.0f;
GLfloat yVal = 700.0f;
GLfloat zVal = 700.0f;

//OBJECTS
struct objects
{
    GLfloat x = 0.0;
    GLfloat y = 500.0;
    GLfloat z = 0.0;

    GLfloat xinc = 0.001;
    GLfloat yinc = 0.001;
    GLfloat zinc = 0.001;

    GLfloat angle = 0.0f;
    GLfloat inc = 0.001f;
} ballObj, stickObj, tableObj, containerObj;

//Mouse
double oldX, oldY;
bool firstMouse = false;

// Define vector to hold the astroids
vector <Model> balls;
vector <objects> objs;

GLfloat groundLevel = 0.0f;
GLfloat tableTop = 1.05f;

GLfloat radius = 0.07f;            // Distance from scene's centre
GLfloat offset = 1.5f;

void init_Resources()
{
    // Init GLFW
    glfwInit();
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);

    // Define the window
    window = glfwCreateWindow(sWidth, sHeight, "COMP3420 - Computer Graphics Project 1", 0, 0);
    glfwMakeContextCurrent(window);

    // Initialize GLEW to setup the OpenGL Function pointers
    glewExperimental = GL_TRUE;
    glewInit();

    //Init Callbacks
    //Callbacks
    glfwSetKeyCallback(window, key_callback);
    glfwSetWindowSizeCallback(window, windowSize_callback);

    glfwSetMouseButtonCallback(window, clicked_callback);

    //glfwSetCursorPosCallback(window, clickDrag_callback);//was acting up
    glfwSetCursorPosCallback(window, moveMouse_callback);

    glfwSetScrollCallback(window, scroll_callback);

    // Define the viewport dimensions
    glViewport(0, 0, sWidth, sHeight);

    // Setup OpenGL options
    glEnable(GL_DEPTH_TEST);

}


// The MAIN function, from here we start our application and run the loop
int main()
{
    init_Resources();

    // ==============================================
    // ====== Set up the stuff for our Objects =======
    // ==============================================
    tableObj.y = 0; //Reset Table Y Axis Since its sitting on the floor

    // =======================================================================
    // Step 1. Setup and compile our shaders as an object of the Shader class
    // =======================================================================
    Shader ballShader("objects/ballVertex.glsl", "objects/ballFragment.glsl");
    Shader tableShader("objects/pooltableVertex.glsl", "objects/pooltableFragment.glsl");

    // =======================================================================
    // Step 2. Load the model objects
    // =======================================================================
    Model ball((GLchar*)"objects/ball.obj");        
    Model table((GLchar*)"objects/pooltable.obj"); //CREDIT: https://free3d.com/3d-model/pool-table-v1--600461.html

    for (int x = 0; x < ballCount; x++)       // Then... The many astroids
    {
        balls.push_back((GLchar*)"objects/ball.obj");
        objs.push_back(objects());
    }

    // =======================================================================
    // Step 3. Set the projection matrix
    // =======================================================================
    glm::mat4 projection = glm::perspective(45.0f, (GLfloat)sWidth / (GLfloat)sHeight, 1.0f, 10000.0f);

    ballShader.Use();
    glUniformMatrix4fv(glGetUniformLocation(ballShader.Program, "projection"), 1, GL_FALSE, glm::value_ptr(projection));

    tableShader.Use();
    glUniformMatrix4fv(glGetUniformLocation(tableShader.Program, "projection"), 1, GL_FALSE, glm::value_ptr(projection));

    srand(glfwGetTime()); // initialize random seed

    ballShader.Use();

    glm::mat4 ballModel[ballCount];

    for (int i = 0; i < ballCount; i++)
        ballModel[i] = glm::mat4(1);

    for (int i = 0; i < ballCount-1; i++)
    {
        ballModel[i] = glm::scale(ballModel[i], glm::vec3(200.0f));

        // 1. Translation: Randomly displace along circle with radius 'radius' in range [-offset, offset]
        GLfloat displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;

        //objs[i].x = displacement;
        objs[i].x = 0;
        //displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;
        //objs[i].y = -2.5f + displacement * 0.4f; // Height of asteroid field smaller compared to width of x and z

        displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;
        objs[i].z = displacement;

        objs[i].y = tableTop; //place on table

        //ballModel[i] = glm::translate(ballModel[i], glm::vec3(xtemp, ytemp, ztemp));
        ballModel[i] = glm::translate(ballModel[i], glm::vec3(objs[i].x, objs[i].y, objs[i].z));

        ballModel[i] = glm::scale(ballModel[i], glm::vec3(0.05));

        // 3. Rotation: add random rotation around a (semi)randomly picked rotation axis vector
       // GLfloat rotatedAngle = (rand() % 360);
        //ballModel[i] = glm::rotate(ballModel[i], rotatedAngle, glm::vec3(0.4f, 0.6f, 0.8f));

    }

    //White ball to shoot with   
    objs[ballCount-1].x = 0;
    objs[ballCount-1].y = tableTop; //place on table
    objs[ballCount-1].z = 0.0;

    ballModel[ballCount-1] = glm::scale(ballModel[ballCount-1], glm::vec3(0.5));
    ballModel[ballCount-1] = glm::translate(ballModel[ballCount-1], glm::vec3(objs[ballCount-1].x, objs[ballCount-1].y, objs[ballCount-1].z));

    // Iterate this block while the window is open
    while (!glfwWindowShouldClose(window))
    {
        // Calculate deltatime of current frame
        currentFrame = glfwGetTime();
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        // Check and call events
        glfwPollEvents();

        // Clear buffers
        glClearColor(0.8f, 0.8f, 0.8f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);


        // Add transformation matrices

        // 1. The View matrix first...
        tableShader.Use();
        glUniformMatrix4fv(glGetUniformLocation(tableShader.Program, "view"), 1, GL_FALSE, glm::value_ptr(camera.GetViewMatrix()));

        tableShader.Use();
        View = glm::lookAt
        (
            glm::vec3(camLocation.x, camLocation.y, camLocation.z), // Camera is at (0,500,7000), in World Space
            glm::vec3(0, 0, 0),      // and looking at the origin
            glm::vec3(0, 1, 0)       // Head is up (set to 0,-1,0 to look upside-down)
        );

        glUniformMatrix4fv(glGetUniformLocation(tableShader.Program, "view"), 1, GL_FALSE, glm::value_ptr(View));

        //==========================================================================
        // Draw the Planet (Create the model)
        //==========================================================================
        tableShader.Use();
        glm::mat4 tableModel = glm::mat4(1);

        tableModel = glm::scale(tableModel, glm::vec3(5.0f));
        tableModel = glm::translate(tableModel, glm::vec3(tableObj.x, tableObj.y, tableObj.z));

        //for (int i = 0; i < ballCount; i++)
        //{
        //    ballModel[i] = glm::translate(ballModel[i], glm::vec3(objs[i].x, objs[i].y, objs[i].z));
        //}
        //Test if table can move while affected by camera
    /*    tableObj.y += tableObj.inc;
        if ((tableObj.y < -20) || (tableObj.y > 20)) tableObj.inc *= -1;*/

        // make it rotate around the y-axis
        //planetAngle += 0.2;
        //planetModel = glm::rotate(planetModel, planetAngle, glm::vec3(0.0f, 1.0f, 0.0f));

        // ...and 2. The Model matrix
        glUniformMatrix4fv(glGetUniformLocation(tableShader.Program, "model"), 1, GL_FALSE, glm::value_ptr(tableModel));
        table.Draw(tableShader);

        //==========================================================================
        // Draw astroids belt - models have been created and stored in 'rockModel'
        //==========================================================================
        ballShader.Use();
        glUniformMatrix4fv(glGetUniformLocation(ballShader.Program, "view"), 1, GL_FALSE, glm::value_ptr(View));

        
        for (int x = 1; x < ballCount; x++)       //Check if balls are intersecting
        {
            //if (x < ballCount - 2)
            //{
            //    for (int j = x + 1; j < ballCount-2; x++)       //Check if balls are intersecting
            //    {
            //        if ((objs[x].x - objs[j].x) < (radius))
            //        {
            //            objs[x].xinc *= -1;
            //            objs[j].xinc *= -1;
            //        }
            //        //objs[x].z += objs[x].zinc;
            //    }
            //}

            //objs[x].z += objs[x].zinc;
            objs[0].z = 0;
            objs[0].xinc = 0.1;
            //objs[x].zinc = 0.01;
                        
            if (objs[0].x > 0.7 || objs[0].x < -0.7)
                objs[0].xinc *= -1;
            if (objs[0].z > 0.9 || objs[0].z < -0.9)
                objs[0].zinc *= -1;

            /*if (objs[0].z > 0.7)ss
                objs[0].z = 0.7;
            if (objs[0].z < -0.7)
                objs[0].z = -0.7;
            if (objs[0].x > 0.7)
                objs[0].x = 0.7;
            if (objs[0].x < -0.7)
                objs[0].x = -0.7;*/


            objs[0].x += objs[0].xinc;
            //objs[0].z += objs[0].zinc;

            cout << "ball 1  x " << objs[0].x << " y " << objs[0].y << " z " << objs[0].x << "|" << endl;
            ballModel[0] = glm::translate(ballModel[0], glm::vec3(objs[0].x * deltaTime, 0.0, objs[0].z * deltaTime));

            glUniformMatrix4fv(glGetUniformLocation(ballShader.Program, "model"), 1, GL_FALSE, glm::value_ptr(ballModel[0]));
            balls[0].Draw(ballShader);
        }

        // Swap the buffers
        glfwSwapBuffers(window);
    }


    glfwTerminate();
    return 0;
}


// -------------------------------------------------------------------------
// Process keyboard inputs
// -------------------------------------------------------------------------
void key_callback(GLFWwindow* window, int key, int scancode, int action, int mode)
{
    // If ESC is pressed, close the window
    if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GL_TRUE);

    

    //CAMERA CONTROLS
    if (glfwGetKey(window, GLFW_KEY_H) == GLFW_PRESS) // If “H” is pressed, move the camera to the coordinates’ origin
        camLocation = originalLocation;

    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        camLocation.x -= xVal;
    if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        camLocation.x += xVal;
    if (glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)
        camLocation.y += yVal;
    if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS)
        camLocation.y -= yVal;
    if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
    {
        cout << "pressed w : " <<camLocation.z << " |";
        camLocation.z -= zVal;
    }
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        camLocation.z += zVal;

    //Reset Ball spin speed and direction
    if (glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS)
        //inc = 0.001;

    //camera = glm::vec3(camLocation.x, camLocation.y, camLocation.z);

    View = glm::lookAt
    (
        glm::vec3(camLocation.x, camLocation.y, camLocation.z), // Camera is at (0,500,7000), in World Space
        glm::vec3(0, 0, 0),      // and looking at the origin
        glm::vec3(0, 1, 0)       // Head is up (set to 0,-1,0 to look upside-down)
    );
}

void windowSize_callback(GLFWwindow* window, int width, int height)
{
    sWidth = width;
    sHeight = height;

    glViewport(0, 0, width, height);
}

void clicked_callback(GLFWwindow* window, int button, int  action, int mode)
{
    double xpos, ypos;

    if (button == GLFW_MOUSE_BUTTON_LEFT && action == GLFW_PRESS) //Mouse Clicked
    {
        cout << "Left Button Clicked\n";

        //Get current mouse coords on click to store for comparison (see if it moves on release)
        glfwGetCursorPos(window, &xpos, &ypos);

        oldX = xpos;
        oldY = ypos;

        firstMouse = true; //Let program know the mouse is being held down
    }

    if ((button == GLFW_MOUSE_BUTTON_LEFT) && (action == GLFW_RELEASE)) //Mouse Released - Perform Rotary changes to globe
    {
        glfwGetCursorPos(window, &xpos, &ypos);

        if (xpos == oldX)
            //inc = 0; //Stop globe spinning if just a simple left click is recogized (no movement)

        cout << "Released : Cursor Position at (" << xpos << " : " << ypos << ")" << endl;

        //Let program know that mouse is released
        firstMouse = false;

        return;
    }

    if ((button == GLFW_MOUSE_BUTTON_RIGHT) && (action == GLFW_PRESS)) //Mouse Pressed 
    {
        //Let program know that mouse is being held down
        firstMouse = true;
    }
    if ((button == GLFW_MOUSE_BUTTON_RIGHT) && (action == GLFW_RELEASE)) //Mouse Released - Perform Rotary changes to globe
    {
        //Restart globe spinning if just a simple right click is recogized 
        //inc = 0.001;

        //Let program know that mouse is released
        firstMouse = false;
    }
}

void clickDrag_callback(GLFWwindow* window, double xPos, double yPos)
{
    if ((glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_RELEASE)) //Mouse Released - Perform Rotary changes to globe
    {
        glfwGetCursorPos(window, &xPos, &yPos);

        if (xPos < oldX)
        {
           
        }
        if ((xPos > oldX))
        {

        }

        cout << "Released : Cursor Position at (" << xPos << " : " << yPos << ")" << endl;

        firstMouse = false; //Let program know mouse is released

        glfwSetCursorPosCallback(window, moveMouse_callback); //Reset to original callback for mouse movement

        return;
    }
}

void moveMouse_callback(GLFWwindow* window, double xPos, double yPos)
{
    double xpos, ypos;

    //mouse is not occupied with spinning earth function
    if (!firstMouse)
    {

    }
    else
    {
        //The mouse is being clicked which means click and drag Should be activated
        glfwSetCursorPosCallback(window, clickDrag_callback);
        return;
    }
}

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
    //cout << "yoffset " << yoffset << " xoffset " << xoffset << " | ";

    if (yoffset > 0) //Scrolled Foward so Move Camera in
    {
        for (int i = 0; i < 50; i++)
            camLocation.z -= 1.0f;
    }
    if (yoffset < 0) //Scrolled Backward so Move Camera out
    {
        for (int i = 0; i < 50; i++)
            camLocation.z += 1.0f;
    }

    View = glm::lookAt
    (
        glm::vec3(camLocation.x, camLocation.y, camLocation.z), // Camera is at (0,500,7000), in World Space
        glm::vec3(0, 0, 0),      // and looking at the origin
        glm::vec3(0, 1, 0)       // Head is up (set to 0,-1,0 to look upside-down)
    );
    //camera = glm::vec3(camLocation.x, camLocation.y, camLocation.z);
}
